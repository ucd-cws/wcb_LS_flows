---
title: "stream network depth-first search full tree"
author: "Lucy Andrews"
output: html_document
---

```{r results = "hide", message = FALSE}
# SET UP

# load libraries
suppressWarnings(library(magrittr))
suppressWarnings(library(tidyverse))
suppressWarnings(library(stringi))
suppressWarnings(library(knitr))
suppressWarnings(library(kableExtra))

# function to grab the length of the longest list in a list of lists
find_max_list <- function(list_of_lists) {
  list_len <- c()
  for(i in list_of_lists) {
    list_len <- c(list_len, length(i))
  }
  return(max(list_len))
}
```

# input data

- a single `to_from` dataframe
  - `from`: upstream
  - `to`: downstream
- it must be possible for outlet (root) and headwater (leaf) values to be identifiable in the `to_from` dataframe
  - `outlet` (root): `outlets` not listed in `from` column, only `to` column (i.e. they are not upstream of any downstream values)
  - `ends` (leaves): `ends` not listed in `to` column, only `from` column (i.e. they are not downstream of any upstream values)
  
```{r}
# EXAMPLE DATASET

# build dummy dataset to test depth-first traversal starting at ends (leaves), which is later reversed

## adjacency table
to <- c("1", "1", "1", "2", "3", "3", "5", "6", "6", "6")
from <- c("2", "3", "4", "5", "6", "7", "8", "9", "10", "11")
to_from_df <- tibble(from, to)

## outlets (roots)
outlets_list <- to_from_df %>%
  filter(!to %in% from) %>%
  pull(to) %>%
  unique()

## ends (leaves)
ends <- to_from_df %>%
  filter(!from %in% to) %>%
  pull(from)
```

```{r}
# PATHS FROM HEADWATER ENDS (leaves) TO OUTLETS (roots)

# function to recursively move up the tree and produce full paths from leaves to roots
get_next_down <- function(end, to_from, path, outlets) {
  
  path <- paste(path, end, collapse = " ")
  
  if(end %in% outlets) {
    return(sub(".*? ", "", path))
  }
  
  next_down <- to_from[from == end, "to"] %>%
    pull()
  
  get_next_down(end = next_down,
                to_from = to_from,
                path = path,
                outlets = outlets)
  
}
```

```{r}
# EXAMPLE PATH

# test run with dummy dataset to produce a single path
get_next_down(end = "11",
              to_from = to_from_df,
              path = "",
              outlets = outlets_list)
```

```{r}
# FULL RUN ON EXAMPLE DATASET

# create empty dataframe for output
## note that this is not very efficient, as it binds rows rather than fills blank slots in a matrix
output_df <- tibble(end = as.character(),
                    path_up_to_down = as.character(),
                    stringsAsFactors = FALSE)

# loop through all ends to generate paths to outlets and then populate output dataframe
for(end in ends) {
  
  path_full <- get_next_down(end = end,
                             to_from = to_from_df,
                             path = c(),
                             outlets = outlets_list)
  
  row <- tibble(end = as.character(end),
                path_up_to_down = as.character(path_full))
  
  output_df <- rbind(output_df, row)

}

# massage the results to show both upstream and downstream path directions
output_df <- output_df %>%
  mutate(as_list = strsplit(path_up_to_down, " ")) %>%
  pull(as_list) %>%
  lapply(rev) %>%
  lapply(paste0, collapse = " ") %>%
  sapply(toString) %>%
  tibble() %>%
  cbind(output_df, .) %>%
  set_colnames(c("start", "path_up_to_down", "path_down_to_up"))

# check out the results
output_df

# clean up
rm(row, end, ends, from, outlets_list, path_full, to)
```

```{r}
# DATAFRAME OF PATHS FROM UPSTREAM TO DOWNSTREAM

# create a single dataframe that shows all paths from upstream to downstream
up_to_down <- output_df %>%
  select(start, path_up_to_down)
```
```{r message = FALSE}
# DATAFRAME OF ALL UPSTREAM PATH SEGMENTS (long)
# create column headings to populate dataframe separate and
# identify length of longest path to generate pivot_longer iterations
num_cols <- output_df %>%
  mutate(as_list = strsplit(path_up_to_down, " ")) %>%
  pull(as_list) %>%
  lapply(rev) %>%
  find_max_list()

col_names <- paste0("up_", 1:num_cols)

# create down_to_up dataframe
down_to_up <- output_df %>%
  select(path_down_to_up) %>%
  separate(col = path_down_to_up, into = col_names, sep = " ", remove = TRUE, fill = "right")

# iteratively pivot_longer to generate full long format
down_to_up_long <- map_dfr(1:(num_cols - 1), ~down_to_up %>%
                     select(.x:(num_cols)) %>%
                     rename(down = 1) %>%
                     pivot_longer(-down, values_to = "up") %>%
                     select(-name)) %>%
  filter(!is.na(up)) %>%
  unique() %>%
  arrange(down, up)
```

# final outputs

`output_df`: list of paths in between outlets (roots) and end nodes (leaves) in the upstream and downstream directions, organized by headwater endpoint

```{r}
output_df %>%
  kbl() %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

`down_to_up_long`: long-format dataframe that lists all values upstream of a given value; can be grouped by value to collect upstream values

```{r}
down_to_up_long %>%
  kbl() %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```
