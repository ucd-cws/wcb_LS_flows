---
title: "Little Shasta Stream Network"
author: "Ryan Peek"
date: "Updated: `r format(Sys.Date())`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}

# Libraries
suppressPackageStartupMessages({
  library(tidyverse);
  library(nhdplusTools);
  library(glue);
  library(sf);
  library(here);
  library(mapview)})
mapviewOptions(fgb = FALSE)

```

## Data

Here we are using an original flowlines layer that is all streamlines in the watershed. It includes 140 variables associated with each COMID from the NHDPlus dataset. This also includes a few additional pieces including: 

 - `evans` a streamline hand digitized from a spring. 
 - `gages` the 3 USGS/UCD gages in the watershed
 - `h10_ls` the HUC10 boundary revised to include/match subcatchment boundaries
 - `lsh_springs` a list of the main springs that are relevant to functional flow analysis

```{r data}

load(here("data_output/05_network_data_pieces.rda"))

```

Clean up and identify the Locations of Interest (LOI) which are COMIDs in the lower half of the watershed.

```{r}

# reduce fields for plotting purposes
flowlines_map <- flowlines %>% select(id, comid, contains("seq"), hydroseq, gnis_name, areasqkm:divdasqkm, shape_length, streamorde, streamorder_map, streamcalc)

# fix flowlines comid to factor in correct order
flowlines_map <- flowlines_map %>%
  mutate(comid_f = factor(as.character(comid),
                          levels=c(3917198, 3917200, 3917948,
                                   3917950, 3917244, 3917946)))


```


## Overview Map

We've cleaned and removed the canals/non-streams from the catchment map, so this is the overview. Notice there are some "sinks" that do not drain to the mainstem.

```{r mapoverview, echo=FALSE}

mapview(loi_comid, color="coral1", lwd=4, layer.name="LOI Comids") +
  mapview(flowlines_map, color="darkblue", legend=F, lwd=2) +
  mapview(gages, col.regions="black", color="white", cex=5, layer.name="Gages") +
  mapview(catch_final, color=scales::alpha("black",0.2), alpha.regions=0.2, col.regions=NA, legend=FALSE, lwd=0.2) +
  mapview(lsh_springs,layer.name="Springs", col.regions="cyan4") +
  mapview(h10_ls, col.regions="steelblue", alpha.regions=0, color="steelblue", lwd=3,
           layer.name="HUC10 Revised", legend=TRUE)


```

## Leverage the NLDI for Network Flowline Data

The {`nhdplusTools`} package is great for accessing NHDPlus data and attributes. Here we can test it out to grab flowlines upstream of a given point or COMID. 

The flow network is essentially correct starting near the most upstream LOI (COMID==3917948), so we can use that to grab flowlines and test things out. There are multiple sources that can be used to query the NLDI (see `dataRetrieval::get_nldi_sources()`). We will use COMID.

First we make the nldi call for our specific comid.

```{r}
# COMID above diversion: 3917948
# COMID at confluence w Shasta River: 3917946

# get list of comids:
nld_ls <- list(featureSource = "comid",
               featureID = 3917948)
```

Next we can use this to navigate upstream or downstream and pull flowlines, attributes, nodes, etc. Here we will pull all flowlines upstream.

```{r}
# now navigate and plot (UPSTREAM)
# here we get all mainstem and tributary branches for 120 km upstream
get_us <- navigate_nldi(nldi_feature = nld_ls,
              mode = "upstreamTributaries",
              distance_km = 120)$UT 

mapview(get_us, zcol="nhdplus_comid", legend=FALSE) +
  mapview(flowlines_map, color="steelblue", lwd=0.3)
```

And here we can pull all mainstems only (so no diversions or canals), "*DM*" stands for *downstream mainstem*.

```{r}
# now get DOWNSTREAM
get_dm <- navigate_nldi(nldi_feature = nld_ls,
                           mode = "DM",
                           distance_km = 15)$DM #%>%

```

### Plot the Flowline Map

Bind it all together (to get hydroseq data) and plot. 

```{r}

# bind the updated flowlines
nhd_flow <- bind_rows(get_dm, get_us)

df <- flowlines_map %>% filter(comid %in% nhd_flow$nhdplus_comid)

```

Map it!

```{r, echo=FALSE}

mapview(nhd_flow, zcol="nhdplus_comid", legend=FALSE, layer.name="NHD Flowlines", lwd=4) +
  mapview(df, zcol="hydroseq", layer.name="Hydroseq", lwd=2)

```

### Test with An Upstream COMID

Here we can test this with a different comid on one of the smaller tributaries, should pull just those comids.

```{r specNhdcomid}
nld_ls_seg <- list(featureSource = "comid",
               featureID = 3917920)

get_us_seg <- navigate_nldi(nldi_feature = nld_ls_seg,
              mode = "upstreamTributaries",
              distance_km = 120)$UT 

mapview(get_us_seg)

# the comids
get_us_seg$nhdplus_comid

```

So we could just iterate through this NHD call, but that seems inefficient to some degree.

## Filtering Approach

I looked at some alternate approaches of filtering based on hydroseq upstream/downstream, using nodes, etc, but couldn't make it work as expected. 

<!--
```{r filterhydroseq}

# get everything upstream of a given comid
df %>% filter(hydroseq %in% c(filter(df, hydroseq>10087752) %>% pull(hydroseq))) %>% mapview(color="maroon", lwd=5) + mapview(df, zcol="hydroseq", layer.name="Hydroseq")

# that doesn't work, need to stop when it reaches a zero
df %>% 
  filter(hydroseq %in% 
           c(filter(df, hydroseq > 10087752 & 
                      (uphydroseq - lag(uphydroseq)) >= 0) %>% 
                    pull(hydroseq))) %>% 
  mapview(color="maroon", lwd=5) + 
  mapview(df, zcol="hydroseq", layer.name="Hydroseq")


# df %>% st_drop_geometry() %>% 
#   select(contains("comid"),contains("seq")) %>% 
#   mutate(tst = case_when(
#     hydroseq!=0 & hydroseq < uphydroseq ~ glue("{hydroseq}, {uphydroseq}"))) %>% View()

```
-->

### Get Nodes

Just for reference, we can use the same package to get the upstream/downstream NODES, not sure if we can leverage this to filter.


```{r nodes, message=FALSE, warning=FALSE}

# get nodes: Start
starts <- get_node(get_us, "start") %>%
  mutate(comid=get_us$nhdplus_comid,
         ds_ord = rev(seq(1:nrow(.))))

# get nodes end
ends <- get_node(get_us, "end") %>%
  mutate(comid=get_us$nhdplus_comid,
         ds_ord = rev(seq(1:nrow(.))))

# plot
mapview(get_us, color="steelblue", legend=FALSE) +
  mapview(starts, zcol="ds_ord", layer.name="Starts", col.regions=RColorBrewer::brewer.pal(starts$ds_ord, "RdBu")) +
  mapview(ends, zcol="ds_ord", layer.name="Ends")

```

## Lucy's Functions

Take and load functions.

```{r}
# function to grab the length of the longest list in a list of lists
find_max_list <- function(list_of_lists) {
  list_len <- c()
  for(i in list_of_lists) {
    list_len <- c(list_len, length(i))
  }
  return(max(list_len))
}


# function to recursively move up the tree and produce full paths from leaves to roots
get_next_down <- function(end, df, path, outlets) {

  path <- paste(path, end, collapse = " ")

  if(end %in% outlets) {
    return(sub(".*? ", "", path))
  }

  next_down <- df[df$from == end, "to"]
  # this isn't working
  # get_next_down(end = next_down,
  #               to_from = df,
  #               path = path,
  #               outlets = outlets)
  return(next_down)
}
```

Now setup data.

```{r}

# flowlines to from using hydroseq for adjacency table
flowlines_tofrom <- flowlines_map %>% st_drop_geometry() %>%
  # filter to just upstream since we don't need sink coms
  filter(comid %in% get_us$nhdplus_comid) %>%
  select(from = hydroseq, # start with leaves
         to = dnhydroseq) # end 

## outlets (roots)
outlets_list <- flowlines_tofrom %>%
  filter(!to %in% from) %>%
  pull(to) %>%
  unique()

## ends (leaves)
ends <- flowlines_tofrom %>%
  filter(!from %in% to) %>%
  pull(from)


```

Ok, now implement.

```{r}

# make empty df
output_df <- tibble(end = as.character(),
                    path_up_to_down = as.character(),
                    stringsAsFactors = FALSE)

# implement in loop
for(end in ends) {

  path_full <- get_next_down(end = end,
                             df = flowlines_tofrom,
                             path = c(),
                             outlets = outlets_list)

  row <- tibble(end = as.character(end),
                path_up_to_down = as.character(path_full))

  output_df <- rbind(output_df, row)

}

# massage the results to show both upstream and downstream path directions
output_df <- output_df %>%
  mutate(as_list = strsplit(path_up_to_down, " ")) %>%
  pull(as_list) %>%
  lapply(rev) %>%
  lapply(paste0, collapse = " ") %>%
  sapply(toString) %>%
  tibble() %>%
  cbind(output_df, .) %>% # View()
  set_names(c("start", "path_up_to_down", "path_down_to_up"))

DT::datatable(output_df)

# clean up
rm(row, end, ends, outlets_list, path_full)

```

The rearrange and get upstream/downstream options:

```{r}
# create a single dataframe that shows all paths from upstream to downstream
up_to_down <- output_df %>%
  select(start, path_up_to_down)


num_cols <- output_df %>%
  mutate(as_list = strsplit(path_up_to_down, " ")) %>%
  pull(as_list) %>%
  lapply(rev) %>%
  find_max_list()

num_cols

col_names <- paste0("up_", 1:num_cols)

# create down_to_up dataframe
down_to_up <- output_df %>%
  select(path_down_to_up) %>%
  separate(col = path_down_to_up, into = col_names, sep = " ", remove = TRUE, fill = "right")

```

Somehow at this point, `num_cols` is returning 1, a single column and so the next chunk breaks.


```{r, echo=TRUE, eval=FALSE}

# iteratively pivot_longer to generate full long format
down_to_up_long <- map_dfr(1:(num_cols - 1), ~down_to_up %>%
                     select(.x:(num_cols)) %>%
                     rename(down = 1) %>%
                     pivot_longer(-down, values_to = "up") %>%
                     select(-name)) %>%
  filter(!is.na(up)) %>%
  unique() %>%
  arrange(down, up)
```

